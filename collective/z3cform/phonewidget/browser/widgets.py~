import struct
import logging
from decimal import Decimal
from zope.schema.interfaces import IFloat
from zope.interface import implements
import zope.component
import zope.interface
import zope.schema.interfaces
from zope.component import getMultiAdapter
from zope.component.hooks import getSite
from zope import schema
from zope.i18n import translate
from zope.schema.fieldproperty import FieldProperty
from zope.pagetemplate.interfaces import IPageTemplate
from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
from Products.CMFCore.utils import getToolByName
from plone.memoize.view import memoize
from zope.schema.vocabulary import SimpleVocabulary, SimpleTerm
from z3c.form.browser import widget
from z3c.form.browser.text import TextWidget
from z3c.form.browser.radio import RadioWidget
from z3c.form.widget import Widget, FieldWidget
from z3c.form.interfaces import IWidget, ITextWidget, IFormLayer, IFieldWidget, NO_VALUE,\
     IRadioWidget, INPUT_MODE, DISPLAY_MODE, HIDDEN_MODE, IGroupForm, IGroup, ISubForm, IHandlerForm
from z3c.form import util, form, field, button, subform, datamanager, group
from Martronic.Odoo4Plone.config import _

LOG = logging.getLogger(__name__)

class IQuantityWidget(ITextWidget):

    step = schema.Int(title=u"step", required=False)
    min_value = schema.Int(title=u"min", required=False)
    max_value = schema.Int(title=u"max", required=False)
    unit = schema.TextLine(title=u"Unit", required=False)
    
@zope.interface.implementer_only(IQuantityWidget)
class QuantityWidget(TextWidget):
    """QuantityWidget"""
    
    step = FieldProperty(IQuantityWidget['step'])
    min_value = FieldProperty(IQuantityWidget['min_value'])
    max_value = FieldProperty(IQuantityWidget['max_value'])
    unit = FieldProperty(IQuantityWidget['unit'])
    
@zope.component.adapter(zope.schema.interfaces.IField, IFormLayer)
@zope.interface.implementer(IFieldWidget)
def QuantityFieldWidget(field, request):
    """IFieldWidget factory for QuantityWidget."""
    return FieldWidget(field, QuantityWidget(request))

class IPriceWidget(ITextWidget):
    """"""
    price_reduce_formatted = schema.TextLine(title=u"Price Reduce", required=False)
    hasDiscount = schema.Bool(title=u"Has Discount", required=False)

@zope.interface.implementer_only(IPriceWidget)
class PriceWidget(TextWidget):
    """PriceWidget"""

    price_reduce_formatted = FieldProperty(IPriceWidget['price_reduce_formatted'])
    hasDiscount = FieldProperty(IPriceWidget['hasDiscount'])
    
    @property
    def getKlass(self):
        if self.hasDiscount:
            return self.klass+' hasDiscount'
        return self.klass

    
@zope.component.adapter(zope.schema.interfaces.IField, IFormLayer)
@zope.interface.implementer(IFieldWidget)
def PriceFieldWidget(field, request):
    """IFieldWidget factory for PriceWidget."""
    return FieldWidget(field, PriceWidget(request))

class IAttributeRadioWidget(IRadioWidget):
    """Attribute widget"""

@zope.interface.implementer_only(IAttributeRadioWidget)
class AttributeRadioWidget(RadioWidget):
    """Attribute Widget"""

    def update(self):
        """See z3c.form.interfaces.IWidget."""
        super(RadioWidget, self).update()
        widget.addFieldClass(self)
        self.items = []
        for count, term in enumerate(self.terms):
            checked = self.isChecked(term)
            id = '%s-%i' % (self.id, count)
            if zope.schema.interfaces.ITitledTokenizedTerm.providedBy(term):
                label = translate(term.title, context=self.request,
                                  default=term.title)
            else:
                label = util.toUnicode(term.value)
            self.items.append(
                {'id':id, 'name':self.name, 'value':term.token,
                 'label':label, 'checked':checked,
                 'price_extra':term.price_extra, 'price_extra_formatted':term.price_extra_formatted,
                 'available':term.available})

@zope.component.adapter(zope.schema.interfaces.IField, IFormLayer)
@zope.interface.implementer(IFieldWidget)
def AttributeRadioFieldWidget(field, request):
    """IFieldWidget factory for Attribute Widget."""
    return FieldWidget(field, AttributeRadioWidget(request))

class IColorRadioWidget(IRadioWidget):
    """Color widget"""

@zope.interface.implementer_only(IColorRadioWidget)
class ColorRadioWidget(RadioWidget):
    """Color Widget"""

    def update(self):
        """See z3c.form.interfaces.IWidget."""
        super(RadioWidget, self).update()
        widget.addFieldClass(self)
        self.items = []
        for count, term in enumerate(self.terms):
            checked = self.isChecked(term)
            id = '%s-%i' % (self.id, count)
            if zope.schema.interfaces.ITitledTokenizedTerm.providedBy(term):
                label = translate(term.title, context=self.request,
                                  default=term.title)
            else:
                label = util.toUnicode(term.value)
            self.items.append(
                {'id':id, 'name':self.name, 'value':term.token,
                 'label':label, 'checked':checked, 'color':term.color and term.color or term.title,
                 'price_extra':term.price_extra, 'price_extra_formatted':term.price_extra_formatted,
                 'available':term.available})

@zope.component.adapter(zope.schema.interfaces.IField, IFormLayer)
@zope.interface.implementer(IFieldWidget)
def ColorRadioFieldWidget(field, request):
    """IFieldWidget factory for Color Widget."""
    return FieldWidget(field, ColorRadioWidget(request))

class AttributeTerm(SimpleTerm):

    def __init__(self, value, token=None, title=None, color=None, price_extra=None, price_extra_formatted=None, available=True):
        super(AttributeTerm, self).__init__(value, token, title)
        self.color = color
        self.price_extra = price_extra
        self.price_extra_formatted = price_extra_formatted
        self.available = available


class IProductAttributesFormWidget(ITextWidget):
    """"""


@zope.interface.implementer(ISubForm, IHandlerForm, IProductAttributesFormWidget)
class ProductAttributesFormWidget(group.Group, form.Form, Widget):
    """Use the form as a widget"""
    name = ''
    id = ''
    required = False
    klass = "product-attributes-form"
#    field = schema.TextLine(title=_("Variants"))
    error = None

    label = _("Chosse the variant")
    description = ""
    ignoreRequiredOnExtract = True
    css_class = "product-attributes-form-widget"
#    ignoreContext = True
    
#    render = ViewPageTemplateFile("templates/subform-status.pt")
    
    def __init__(self, field, request):
        self.field = field
        self.context = field.context
        self.request = request

    @property
    def product_state(self):
        return self.form.product_state

    def getContent(self):
        return self.product_state
    
    @property
    def prefix(self):
        return self.form.prefix
    
    @property
    def parentForm(self):
        return self.form

    def update(self):
        self.attributes = self.product_state.getAttributes()
#        self.field.default = self.product_state.id
        form.Form.update(self)
        Widget.update(self)

    @property
    def fields(self):
        if len(self.product_state.variants)<=1:
            return field.Fields([field.Field(schema.Int(__name__='product_id',
                                  title=u'Product ID',))])
        afields = []
        vals_available = {}
        if self.request.get('cur_attribute'):
            cur_attribute = self.request.get('cur_attribute')
            cur_value = int(self.request.get('cur_value'))
        else:
            var = self.product_state.variants[0]
            cur_attribute = var['attribute_values'].keys()[0]
            cur_value = var['attribute_values'].values()[0]['id']
        for variant in self.product_state.variants:
            if variant['attribute_values'].get(cur_attribute)['id'] != cur_value:
                continue
            for k,v in variant['attribute_values'].items():
                if k != cur_attribute:
                    if not vals_available.get(k):
                        vals_available[k] = []
                    vals_available[k].append(v['id'])
        defaults = {}
        for k,v in self.product_state.variants[0]['attribute_values'].items():
            defaults[k] = v['id']
        for k,v in self.attributes.items():
            voc = []
            for val_id, val in v['values'].items():
                available = True
                if vals_available.get(k) != None:
                    available = val_id in vals_available[k]
                title=val['value']
                if v['type'] == 'select' and val['price_extra']:
                    if val['price_extra'] >= 0:
                        title += ' + '+val['price_extra_formatted']
                    else:
                        title += ' - '+val['price_extra_formatted']
                voc.append(AttributeTerm(value=str(val_id), title=title, color=val['color'], price_extra=val['price_extra'], price_extra_formatted=val['price_extra_formatted'], available=available))
            baseField = schema.Choice(__name__='attr_'+str(v['attribute_id']),
                                  title=unicode(v.get('name')),
                                  required=self.field.required,
                                  vocabulary=SimpleVocabulary(voc),
                                  default=str(defaults[k])
                                  )
            zField = field.Field(baseField, showDefault=True)
            if v['type'] == 'radio':
                zField.widgetFactory = AttributeRadioFieldWidget
            if v['type'] == 'color':
                zField.widgetFactory = ColorRadioFieldWidget
            afields.append(zField)
        fields = field.Fields(*afields)
        return fields

    def updateWidgets(self):
        form.Form.updateWidgets(self)
#        for k,v in self.product_state.attributes.items():
#            key = 'attr_'+str(v['attribute_id'])
#            if self.widgets.get(key):
#                val = str(v['id'])
#                self.widgets[key].value = [val,]
    
    def extract(self, default=NO_VALUE):
        LOG.info('EXTRACTING')
        data, errors = self.extractData()
        if not data:
            return NO_VALUE
        if errors and default==None:
            # errors on the form
            self.status = _(u"Please fill in all the fields.")
            return NO_VALUE
        product_id = NO_VALUE
        for variant in self.product_state.variants:
            product_found = True
            for k,v in self.attributes.items():
                value = data['attr_'+str(k)]
                found = False
                for l,av in variant['attribute_values'].items():
                    if k == l and str(value) == str(av['id']):
                        found = True
                        break
                if found:
                    continue
                else:
                    product_found = False
                    break
            if product_found:
                product_id = variant['id']
                break
        LOG.info('return '+str(product_id))
        return product_id

    @button.buttonAndHandler(_('Choose'), name='attributes_choose', condition=lambda form: len(form.product_state.variants)>1)
    def choose(self, action):
        product_id = self.extract()
        if product_id == None:
            self.status = _(u"This variant is not available.")
            return
        base_product_id = self.product_state.id
        if base_product_id != product_id:
            content = getattr(self.parentForm,'content', None)
            self.form.updateContent(product_id)
            self.updateWidgets()

    def render(self):
        return Widget.render(self)

    def __call__(self):
        return Widget.__call__(self)

@zope.component.adapter(zope.schema.interfaces.IField, IFormLayer)
@zope.interface.implementer(IFieldWidget)
def ProductVariantFieldWidget(field, request):
    """IFieldWidget factory for ProductVariantFieldWidget."""
    return FieldWidget(field, ProductAttributesFormWidget(field, request))


class IAddToCartFormWidget(IWidget):
    """"""

@zope.interface.implementer(ISubForm, IHandlerForm, IAddToCartFormWidget)
class AddToCartFormWidget(group.Group, form.Form, Widget):
    """Use the form as a widget"""
    name = ''
    id = ''
    required = False
    klass = "product-attributes-form"
    error = None

    label = ""
    description = ""
    ignoreRequiredOnExtract = True
#    ignoreContext = True
    
    render = ViewPageTemplateFile("templates/subform-status-edit.pt")
    fields = field.Fields()

    def __init__(self, field, request):
        self.field = field
        self.context = field.context
        self.request = request

    @property
    def product_state(self):
        return self.form.product_state
        
    @property
    def odoo_state(self):
        return self.form.odoo_state
        
    def getContent(self):
        return self.product_state
    
    @property
    def prefix(self):
        return self.form.prefix
    
    @property
    def parentForm(self):
        return self.form

    def update(self):
#        self.field.default = self.product_state.product_id
        form.Form.update(self)
        Widget.update(self)

    def updateWidgets(self):
        form.Form.updateWidgets(self)

    @button.buttonAndHandler(_('Add to cart'), name='add')
    def add(self, action):
        product_id = self.product_state.product_id
        if product_id == None:
            self.parentForm.manager.status = _(u"No Product provided. Please contact the site administration.")
            return
        else:
            product_id = int(product_id)
        content = self.getContent()
        linked_line_id = content.linked_line_id
        if 'option_' in str(content.linked_line_id):
            linked_line_id = int(str(content.linked_line_id).split('.option_')[0])
        LOG.info('content: '+str(content))
        LOG.info('linked_line_id: '+str(linked_line_id))
        sale_order = self.odoo_state.updateCart(product_id=product_id, add_qty=content.set_qty, linked_line_id=linked_line_id)
        if not sale_order:
            self.parentForm.manager.status = _(u"Cannot connect to Odoo servers. Please contact web site administration.")
            return
        ok_message = _(u"The product has been added to you cart.")
        pu = getToolByName(getSite(), "plone_utils")
        pu.addPortalMessage(ok_message, type='info')
        self.request.response.redirect(self.request.get('ACTUAL_URL'))

    def __call__(self):
        return Widget.__call__(self)

@zope.component.adapter(zope.schema.interfaces.IField, IFormLayer)
@zope.interface.implementer(IFieldWidget)
def AddToCartFieldWidget(field, request):
    """IFieldWidget factory for ProductVariantFieldWidget."""
    return FieldWidget(field, AddToCartFormWidget(field, request))
